<!DOCTYPE html>
<head>
    <title>ikun å¯†æ–‡</title>
    <link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-webfont@1.6.0/lxgwwenkai-bold.css">
    <style>
        * {
            font-family: 'LXGW WenKai', sans-serif;
        }
        textarea {
            height: auto;
            resize: none;
            max-height: 300px;
            min-height: 38px;
            overflow-y: hidden;
        }
        .panel, .btn-group, img, footer {
            margin: 10px 0;
        }
        button {
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>æ–‡å­—åŠ å¯†/è§£å¯†</h1>
        </header>
        
        <div class="panels">
            <div class="panel">
                <div class="panel-title">
                    <h3>æ–‡æœ¬</h3>
                </div>
                <div class="panel-content">
                    <textarea id="originalText" placeholder="è¾“å…¥åŸæ–‡æˆ–å¯†æ–‡..." oninput="this.style.height='auto';this.style.height=Math.min(this.scrollHeight, 300)+'px';"></textarea>
                    <div class="btn-group">
                        <button onclick="encryptText()">åŠ å¯†</button>
                        <button onclick="decryptText()">è§£å¯†</button>
                        <button onclick="clearText('originalText')">æ¸…ç©º</button>
                    </div>
                </div>
            </div>
            <div class="panel" id="resultPanel" style="display: none;">
                <div class="panel-title">
                    <h3>ç»“æœ</h3>
                </div>
                <div class="panel-content">
                    <textarea id="resultText" readonly oninput="this.style.height='auto';this.style.height=Math.min(this.scrollHeight, 300)+'px';"></textarea>
                    <div class="btn-group">
                        <button class="btn-copy" onclick="copyToClipboard('resultText')">å¤åˆ¶</button>
                    </div>
                </div>
            </div>
        </div>
        <img src="https://assets-hs-cdn.soutushenqi.com/ai_images/f1930d52-2aab-4fcf-8fff-200187df9a18.png" width="200" height="200">
    </div>
    <footer>
        <a href="https://github.com/ghrmoe/ikun-encrypter">GitHub ä»“åº“</a>
        <p>ä¸è¦ä¸€æ¬¡ç²˜è´´å¤ªå¤šæ–‡å­—å“¦ï¼</p>
    </footer>

    <script>
        const targetChars = [
            "å…¨æ°‘åˆ¶ä½œäºº", "è”¡å¾å¤", "åªå› ", "ä½ å¤ªç¾", "è´è´",
            "è ¢è ¢æ¬²åŠ¨", "é¸½é¸½", "èåŒ–", "å¤§å®¶å¥½", "çˆ†ç‚¸",
            "å ä¸ºå·±æœ‰", "ä¸¤å¹´åŠ", "ç»ƒä¹ ç”Ÿ", "ä½ å¹²å˜›", "å“ˆå“ˆ",
            "å“å“Ÿ", "å”±è·³", "rap", "ç¯®çƒ", "music",
            "é¸¡", "ğŸ”", "ğŸ¤", "ğŸ€"
        ];
        const targetLen = targetChars.length;

        class EncryptDecryptSystem {
            constructor() {
                this.charMap = {};
                this.reverseMap = {};
                for (let i = 0; i < targetLen; i++) {
                    this.charMap[i] = targetChars[i];
                    this.reverseMap[targetChars[i]] = i;
                }
            }

            encode(inputString) {
                if (!inputString) return "";
                const byteData = new TextEncoder().encode(inputString);
                let num = BigInt(0);
                for (let i = 0; i < byteData.length; i++) {
                    num = num * BigInt(256) + BigInt(byteData[i]);
                }
                const encodedResult = [];
                if (num === 0n) {
                    encodedResult.push(this.charMap[0]);
                } else {
                    while (num > 0n) {
                        const digit = Number(num % BigInt(targetLen));
                        encodedResult.push(this.charMap[digit]);
                        num = num / BigInt(targetLen);
                    }
                }
                return encodedResult.reverse().join('');
            }

            decode(encodedString) {
                if (!encodedString) return "";
                let num = BigInt(0);
                let i = 0;
                while (i < encodedString.length) {
                    let found = false;
                    for (let len = Math.min(6, encodedString.length - i); len > 0; len--) {
                        const testChar = encodedString.substring(i, i + len);
                        if (this.reverseMap.hasOwnProperty(testChar)) {
                            num = num * BigInt(targetLen) + BigInt(this.reverseMap[testChar]);
                            i += len;
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        throw new Error(`æ— æ•ˆå­—ç¬¦ at position ${i}`);
                    }
                }
                const byteData = [];
                while (num > 0n) {
                    byteData.push(Number(num % 256n));
                    num = num / 256n;
                }
                return new TextDecoder().decode(new Uint8Array(byteData.reverse()));
            }
        }

        const system = new EncryptDecryptSystem();
        const originalText = document.getElementById('originalText');
        const resultText = document.getElementById('resultText');
        const resultPanel = document.getElementById('resultPanel');

        function encryptText() {
            try {
                const result = system.encode(originalText.value);
                resultText.value = result;
                resultText.style.height = 'auto';
                resultText.style.height = Math.min(resultText.scrollHeight, 300) + 'px';
                resultPanel.style.display = 'block';
            } catch (e) {
                resultText.value = "åŠ å¯†å¤±è´¥: " + e.message;
                resultPanel.style.display = 'block';
            }
        }

        function decryptText() {
            try {
                const result = system.decode(originalText.value);
                resultText.value = result;
                resultText.style.height = 'auto';
                resultText.style.height = Math.min(resultText.scrollHeight, 300) + 'px';
                resultPanel.style.display = 'block';
            } catch (e) {
                resultText.value = "è§£å¯†å¤±è´¥: " + e.message;
                resultPanel.style.display = 'block';
            }
        }

        function copyToClipboard(id) {
            const textarea = document.getElementById(id);
            textarea.select();
            document.execCommand('copy');
            const btn = document.querySelector('.btn-copy');
            btn.textContent = 'å·²å¤åˆ¶';
            setTimeout(() => {
                btn.textContent = 'å¤åˆ¶';
            }, 3000);
        }

        function clearText(id) {
            document.getElementById(id).value = '';
            document.getElementById(id).style.height = 'auto';
            resultText.value = '';
            resultPanel.style.display = 'none';
        }
    </script>
</body>
</html>
