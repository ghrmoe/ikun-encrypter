<!DOCTYPE html>
<head>
    <title>ikun 密文</title>
    <link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-webfont@1.6.0/lxgwwenkai-bold.css">
    <style>
        * {
            font-family: 'LXGW WenKai', sans-serif;
        }
        textarea {
            height: auto;
            resize: none;
            max-height: 300px;
            min-height: 38px;
            overflow-y: hidden;
        }
        .panel, .btn-group, img, footer {
            margin: 10px 0;
        }
        button {
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>文字加密/解密</h1>
        </header>
        
        <div class="panels">
            <div class="panel">
                <div class="panel-title">
                    <h3>文本</h3>
                </div>
                <div class="panel-content">
                    <textarea id="originalText" placeholder="输入原文或密文..." oninput="this.style.height='auto';this.style.height=Math.min(this.scrollHeight, 300)+'px';"></textarea>
                    <div class="btn-group">
                        <button onclick="encryptText()">加密</button>
                        <button onclick="decryptText()">解密</button>
                        <button onclick="clearText('originalText')">清空</button>
                    </div>
                </div>
            </div>
            <div class="panel" id="resultPanel" style="display: none;">
                <div class="panel-title">
                    <h3>结果</h3>
                </div>
                <div class="panel-content">
                    <textarea id="resultText" readonly oninput="this.style.height='auto';this.style.height=Math.min(this.scrollHeight, 300)+'px';"></textarea>
                    <div class="btn-group">
                        <button class="btn-copy" onclick="copyToClipboard('resultText')">复制</button>
                    </div>
                </div>
            </div>
        </div>
        <img src="https://assets-hs-cdn.soutushenqi.com/ai_images/f1930d52-2aab-4fcf-8fff-200187df9a18.png" width="200" height="200">
    </div>
    <footer>
        <a href="https://github.com/ghrmoe/ikun-encrypter">GitHub 仓库</a>
        <p>不要一次粘贴太多文字哦！</p>
    </footer>

    <script>
        const targetChars = [
            "全民制作人", "蔡徐坤", "只因", "你太美", "贝贝",
            "蠢蠢欲动", "鸽鸽", "融化", "大家好", "爆炸",
            "占为己有", "两年半", "练习生", "你干嘛", "哈哈",
            "哎哟", "唱跳", "rap", "篮球", "music",
            "鸡", "🐔", "🐤", "🏀"
        ];
        const targetLen = targetChars.length;

        class EncryptDecryptSystem {
            constructor() {
                this.charMap = {};
                this.reverseMap = {};
                for (let i = 0; i < targetLen; i++) {
                    this.charMap[i] = targetChars[i];
                    this.reverseMap[targetChars[i]] = i;
                }
            }

            encode(inputString) {
                if (!inputString) return "";
                const byteData = new TextEncoder().encode(inputString);
                let num = BigInt(0);
                for (let i = 0; i < byteData.length; i++) {
                    num = num * BigInt(256) + BigInt(byteData[i]);
                }
                const encodedResult = [];
                if (num === 0n) {
                    encodedResult.push(this.charMap[0]);
                } else {
                    while (num > 0n) {
                        const digit = Number(num % BigInt(targetLen));
                        encodedResult.push(this.charMap[digit]);
                        num = num / BigInt(targetLen);
                    }
                }
                return encodedResult.reverse().join('');
            }

            decode(encodedString) {
                if (!encodedString) return "";
                let num = BigInt(0);
                let i = 0;
                while (i < encodedString.length) {
                    let found = false;
                    for (let len = Math.min(6, encodedString.length - i); len > 0; len--) {
                        const testChar = encodedString.substring(i, i + len);
                        if (this.reverseMap.hasOwnProperty(testChar)) {
                            num = num * BigInt(targetLen) + BigInt(this.reverseMap[testChar]);
                            i += len;
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        throw new Error(`无效字符 at position ${i}`);
                    }
                }
                const byteData = [];
                while (num > 0n) {
                    byteData.push(Number(num % 256n));
                    num = num / 256n;
                }
                return new TextDecoder().decode(new Uint8Array(byteData.reverse()));
            }
        }

        const system = new EncryptDecryptSystem();
        const originalText = document.getElementById('originalText');
        const resultText = document.getElementById('resultText');
        const resultPanel = document.getElementById('resultPanel');

        function encryptText() {
            try {
                const result = system.encode(originalText.value);
                resultText.value = result;
                resultText.style.height = 'auto';
                resultText.style.height = Math.min(resultText.scrollHeight, 300) + 'px';
                resultPanel.style.display = 'block';
            } catch (e) {
                resultText.value = "加密失败: " + e.message;
                resultPanel.style.display = 'block';
            }
        }

        function decryptText() {
            try {
                const result = system.decode(originalText.value);
                resultText.value = result;
                resultText.style.height = 'auto';
                resultText.style.height = Math.min(resultText.scrollHeight, 300) + 'px';
                resultPanel.style.display = 'block';
            } catch (e) {
                resultText.value = "解密失败: " + e.message;
                resultPanel.style.display = 'block';
            }
        }

        function copyToClipboard(id) {
            const textarea = document.getElementById(id);
            textarea.select();
            document.execCommand('copy');
            const btn = document.querySelector('.btn-copy');
            btn.textContent = '已复制';
            setTimeout(() => {
                btn.textContent = '复制';
            }, 3000);
        }

        function clearText(id) {
            document.getElementById(id).value = '';
            document.getElementById(id).style.height = 'auto';
            resultText.value = '';
            resultPanel.style.display = 'none';
        }
    </script>
</body>
</html>
